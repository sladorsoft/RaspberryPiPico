.program ws2812d
.side_set 1 opt

    pull block                  ; pull the next data (number of LEDs - 1)
    out y, 32                   ; and put it to "Y"

.wrap_target
    mov x, y                    ; initialise the LED counter "X" with the value of "Y"
next_led:
    pull block                  ; pull the next data (RGB value for a LED)
    irq 0                       ; set INT 0 flag
    out null, 8                 ; ignore the trailing 8 bits

next_bit:
    mov pins, !null             ; set the GPIO to "1"
; this could also be: "nop side 1"

    out pins, 1                 ; the middle 1/3 is equal to actual value we send
    jmp !osre next_bit side 0   ; set the GPIO to "0", jump if the shift register contains more bits
                                ; shift register empty -> no more data to send for a LED

    jmp x-- next_led            ; jump if more LEDs to send data to
                                ; here we are done - introduce the 50us reset delay
                                ; wait 120 cycles (50us = 40 bit lengths * 3)
    set x, 14                   ; 120 = 15 * 8 (set "X" to 15-1)
delay_loop:
    jmp x-- delay_loop [7]      ; 1 + 7 cycles in each iteration

    irq clear 0                 ; clear INT 0 flag
.wrap


% c-sdk {

void ws2812d_program_init(PIO pio, uint sm, uint offset, uint pin)
{
    pio_sm_config cfg = ws2812d_program_get_default_config(offset);
    sm_config_set_out_shift(&cfg, false, false, 32);
    sm_config_set_clkdiv(&cfg, (clock_get_hz(clk_sys) / 1e6f) * 1.25f / 3.0f);    // 1.25us / 3
    sm_config_set_out_pins(&cfg, pin, 1);
    sm_config_set_sideset_pins(&cfg, pin);

    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);

    pio_sm_init(pio, sm, offset, &cfg);
}
%}
